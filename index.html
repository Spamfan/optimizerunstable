<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Framework 3: Tank Render & Min/Max FPS</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #333; touch-action: none; }
        canvas { display: block; width: 100%; height: 100%; }
        
        #debug-overlay {
            position: fixed; top: 10px; left: 10px;
            color: #00FF00; font-family: monospace; font-size: 16px; font-weight: bold;
            background: rgba(0,0,0,0.6); padding: 8px; pointer-events: none; border-radius: 4px;
        }

        #joystick-zone {
            position: fixed; bottom: 50px; left: 50px;
            width: 150px; height: 150px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            touch-action: none;
        }
        #joystick-knob {
            position: absolute; top: 50%; left: 50%;
            width: 50px; height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="debug-overlay">
        FPS: <span id="fps-cur">0</span><br>
        Min: <span id="fps-min" style="color: #ff4444;">0</span><br>
        Max: <span id="fps-max" style="color: #44ff44;">0</span><br>
        Objs: 2000 Tanks
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="joystick-zone"><div id="joystick-knob"></div></div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // State
    let width, height;
    const gridSize = 40;
    const worldSize = 4000;
    let camera = { x: 0, y: 0 };
    
    let player = { x: 2000, y: 2000, width: 35, height: 35, speed: 8, angle: 0, turretAngle: 0 };
    let joystick = { active: false, dx: 0, dy: 0 };
    
    // GENERATE 2000 "TANKS" (Dummy objects)
    let worldObjects = [];
    function generateWorld() {
        for(let i=0; i<2000; i++) {
            worldObjects.push({
                x: Math.random() * worldSize,
                y: Math.random() * worldSize,
                angle: Math.random() * Math.PI * 2,
                turretAngle: Math.random() * Math.PI * 2,
                width: 35,
                height: 35,
                color: Math.random() > 0.5 ? '#991b1b' : '#7f1d1d' // Enemy Colors
            });
        }
    }
    generateWorld();

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // Joystick Logic
    const joyZone = document.getElementById('joystick-zone');
    const joyKnob = document.getElementById('joystick-knob');
    const joyRect = joyZone.getBoundingClientRect();
    const joyCenter = { x: joyRect.left + joyRect.width/2, y: joyRect.top + joyRect.height/2 };

    joyZone.addEventListener('touchstart', (e) => {
        e.preventDefault();
        joystick.active = true;
        updateJoystick(e.changedTouches[0]);
    }, { passive: false });

    joyZone.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if(joystick.active) updateJoystick(e.changedTouches[0]);
    }, { passive: false });

    const endJoystick = (e) => {
        e.preventDefault();
        joystick.active = false;
        joystick.dx = 0; joystick.dy = 0;
        joyKnob.style.transform = `translate(-50%, -50%)`;
    };
    joyZone.addEventListener('touchend', endJoystick);
    joyZone.addEventListener('touchcancel', endJoystick);

    function updateJoystick(touch) {
        const maxDist = 50;
        let dx = touch.clientX - joyCenter.x;
        let dy = touch.clientY - joyCenter.y;
        const dist = Math.hypot(dx, dy);
        const visualDist = Math.min(dist, maxDist);
        const angle = Math.atan2(dy, dx);
        joyKnob.style.transform = `translate(calc(-50% + ${Math.cos(angle)*visualDist}px), calc(-50% + ${Math.sin(angle)*visualDist}px))`;
        if (dist > 10) { joystick.dx = dx / dist; joystick.dy = dy / dist; } 
        else { joystick.dx = 0; joystick.dy = 0; }
    }

    // --- RENDERER (The Test Subject) ---
    function drawTank(t) {
        ctx.save();
        ctx.translate(t.x + t.width / 2, t.y + t.height / 2);
        
        // Body
        ctx.save();
        ctx.rotate(t.angle);
        ctx.lineWidth = 3;
        ctx.strokeStyle = 'black';
        ctx.fillStyle = "#4A5568"; // Tracks
        ctx.strokeRect(-t.width / 2, -t.height / 2, t.width, t.height);
        ctx.fillRect(-t.width / 2, -t.height / 2, t.width, t.height);
        ctx.fillStyle = t.color || "#3b82f6"; // Body
        ctx.strokeRect(-t.width / 2 * 0.8, -t.height / 2 * 0.8, t.width * 0.8, t.height * 0.8);
        ctx.fillRect(-t.width / 2 * 0.8, -t.height / 2 * 0.8, t.width * 0.8, t.height * 0.8);
        ctx.restore();

        // Turret
        ctx.rotate(t.turretAngle);
        ctx.fillStyle = "#718096";
        ctx.strokeRect(-t.width/4, -t.height/8, t.width/2, t.height/4);
        ctx.fillRect(-t.width/4, -t.height/8, t.width/2, t.height/4);
        ctx.restore();
    }

    // --- LOOP & DIAGNOSTICS ---
    let lastTime = performance.now();
    let frames = 0;
    let lastFpsTime = lastTime;
    let minFps = 60;
    let maxFps = 0;

    function loop(now) {
        // FPS Logic
        frames++;
        const delta = now - lastTime;
        const instantFps = 1000 / delta;
        lastTime = now;

        if (instantFps < minFps && frames > 5) minFps = instantFps; // Ignore startup spike
        if (instantFps > maxFps) maxFps = instantFps;

        if (now - lastFpsTime >= 1000) {
            document.getElementById('fps-cur').textContent = Math.round(frames);
            document.getElementById('fps-min').textContent = Math.round(minFps);
            document.getElementById('fps-max').textContent = Math.round(maxFps);
            frames = 0;
            minFps = 60; // Reset min/max every second
            maxFps = 0;
            lastFpsTime = now;
        }

        // Update
        if (joystick.active) {
            player.x += joystick.dx * player.speed;
            player.y += joystick.dy * player.speed;
            player.angle = Math.atan2(joystick.dy, joystick.dx);
            player.turretAngle = player.angle; // Lock turret to body for this test
        }
        camera.x = player.x - width / 2;
        camera.y = player.y - height / 2;

        // Draw
        ctx.clearRect(0, 0, width, height);
        ctx.save();
        ctx.translate(-camera.x, -camera.y);

        // Ground
        const startCol = Math.floor(camera.x / gridSize);
        const endCol = startCol + (width / gridSize) + 1;
        const startRow = Math.floor(camera.y / gridSize);
        const endRow = startRow + (height / gridSize) + 1;
        for (let c = startCol; c <= endCol; c++) {
            for (let r = startRow; r <= endRow; r++) {
                ctx.fillStyle = (c + r) % 2 === 0 ? '#48D43B' : '#3eb532';
                ctx.fillRect(c * gridSize, r * gridSize, gridSize, gridSize);
            }
        }

        // Draw 2000 Tanks
        for (const obj of worldObjects) {
            drawTank(obj);
        }
        
        // Draw Player
        drawTank(player);

        ctx.restore();
        requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);

</script>
</body>
</html>